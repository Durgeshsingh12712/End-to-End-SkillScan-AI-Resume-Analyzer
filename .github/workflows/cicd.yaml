name: SkillScan AI Resume Analyzer CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - 'README.md'
      - '*.md'
      - '.gitignore'
  pull_request:
    branches:
      - main
    paths-ignore:
      - 'README.md'
      - '*.md'
      - '.gitignore'

permissions:
  id-token: write
  contents: read

env:
  PYTHON_VERSION: '3.8'
  IMAGE_TAG: ${{ github.sha }}
  APP_NAME: SkillScan-AI-Resume-Analyzer-app

jobs:
  integration:
    name: Continuous Integration
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python 3.8
        uses: actions/setup-python@v4
        with:
          python-version: '3.8'

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest pytest-cov black isort safety bandit
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Code formatting with Black
        run: |
          black --check --diff .

      - name: Import sorting with isort
        run: |
          isort --check-only --diff .

      - name: Lint with flake8
        run: |
          # Stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # Exit-zero treats all errors as warnings
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Security check with bandit
        run: |
          bandit -r . -x ./tests/ -ll

      - name: Safety check for known vulnerabilities
        run: |
          safety check

      - name: Run unit tests
        run: |
          if [ -d "tests" ]; then
            pytest tests/ -v --cov=skillScan --cov-report=xml --cov-report=html
          else
            echo "No tests directory found, skipping tests"
          fi

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: integration
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  build-and-push-ecr-image:
    name: Build and Push to ECR
    needs: [integration, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    outputs:
      image: ${{ steps.build-image.outputs.image }}
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names ${{ secrets.ECR_REPOSITORY_NAME }} || \
          aws ecr create-repository --repository-name ${{ secrets.ECR_REPOSITORY_NAME }}

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        run: |
          # Build Docker image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Push both tagged and latest versions
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Scan Docker image for vulnerabilities
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $HOME/Library/Caches:/root/.cache/ \
            aquasec/trivy:latest image \
            --exit-code 0 --no-progress --format table \
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

  deploy-staging:
    name: Deploy to Staging
    needs: build-and-push-ecr-image
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: http://staging.yourapp.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Pull latest image
        run: |
          docker pull ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

      - name: Stop and remove existing staging container
        run: |
          docker ps -q --filter "name=SkillScan-AI-Resume-Analyzer-staging" | grep -q . && \
          docker stop SkillScan-AI-Resume-Analyzer-staging && \
          docker rm -fv SkillScan-AI-Resume-Analyzer-staging || true

      - name: Run Docker Image in Staging
        run: |
          docker run -d -p 8080:5000 --name=SkillScan-AI-Resume-Analyzer-staging \
            --restart=unless-stopped \
            -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            -e 'AWS_REGION=${{ secrets.AWS_REGION }}' \
            -e 'FLASK_ENV=staging' \
            -e 'SECRET_KEY=${{ secrets.SECRET_KEY }}' \
            -v /tmp/SkillScan-AI-Resume-Analyzer-uploads:/tmp \
            --health-cmd="curl -f http://localhost:5000/ || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

      - name: Health check staging deployment
        run: |
          sleep 30
          curl -f http://localhost:8080/ || exit 1

      - name: Run staging tests
        run: |
          # Add staging-specific tests here
          echo "Running staging integration tests"

  deploy-production:
    name: Deploy to Production
    needs: deploy-staging
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://production.yourapp.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Pull latest image
        run: |
          docker pull ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

      - name: Create backup of current production container
        run: |
          if docker ps -q --filter "name=SkillScan-AI-Resume-Analyzer-prod" | grep -q .; then
            docker commit SkillScan-AI-Resume-Analyzer-prod SkillScan-AI-Resume-Analyzer-backup:$(date +%Y%m%d-%H%M%S)
          fi

      - name: Deploy to production with zero downtime
        run: |
          # Pull new image
          docker pull ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}
          
          # Start new container on different port
          docker run -d -p 8081:5000 --name=SkillScan-AI-Resume-Analyzer-prod-new \
            --restart=unless-stopped \
            -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            -e 'AWS_REGION=${{ secrets.AWS_REGION }}' \
            -e 'FLASK_ENV=production' \
            -e 'SECRET_KEY=${{ secrets.SECRET_KEY }}' \
            -v /tmp/SkillScan-AI-Resume-Analyzer-uploads:/tmp \
            -v /var/log/SkillScan-AI-Resume-Analyzer:/var/log/app \
            --health-cmd="curl -f http://localhost:5000/ || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

      - name: Health check new production deployment
        run: |
          sleep 30
          for i in {1..10}; do
            if curl -f http://localhost:8081/; then
              echo "Health check passed"
              break
            fi
            echo "Health check failed, retrying in 10 seconds..."
            sleep 10
          done

      - name: Switch traffic to new container
        run: |
          # Stop old container if exists
          if docker ps -q --filter "name=SkillScan-AI-Resume-Analyzer-prod" | grep -q .; then
            docker stop SkillScan-AI-Resume-Analyzer-prod
            docker rm SkillScan-AI-Resume-Analyzer-prod
          fi
          
          # Stop new container and restart on production port
          docker stop SkillScan-AI-Resume-Analyzer-prod-new
          docker rm SkillScan-AI-Resume-Analyzer-prod-new
          
          # Start final production container
          docker run -d -p 8080:5000 --name=SkillScan-AI-Resume-Analyzer-prod \
            --restart=unless-stopped \
            -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            -e 'AWS_REGION=${{ secrets.AWS_REGION }}' \
            -e 'FLASK_ENV=production' \
            -e 'SECRET_KEY=${{ secrets.SECRET_KEY }}' \
            -v /tmp/SkillScan-AI-Resume-Analyzer-uploads:/tmp \
            -v /var/log/SkillScan-AI-Resume-Analyzer:/var/log/app \
            --health-cmd="curl -f http://localhost:5000/ || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}

      - name: Final health check
        run: |
          sleep 30
          curl -f http://localhost:8080/ || exit 1

      - name: Clean up old images and containers
        run: |
          docker system prune -f
          # Keep only last 5 images
          docker images ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ secrets.ECR_REPOSITORY_NAME }} --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | tail -n +6 | awk '{print $3}' | xargs -r docker rmi || true

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    
    steps:
      - name: Notify on Success
        if: needs.deploy-production.result == 'success'
        run: |
          echo "✅ Deployment to production successful!"
          # Add notification logic here (Slack, email, etc.)
          
      - name: Notify on Failure
        if: needs.deploy-production.result == 'failure'
        run: |
          echo "❌ Deployment to production failed!"
          # Add notification logic here (Slack, email, etc.)